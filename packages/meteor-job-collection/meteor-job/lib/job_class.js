// Generated by CoffeeScript 1.12.2
(function() {
  var Job, JobQueue, _clearInterval, _setImmediate, _setInterval, concatReduce, isBoolean, isFunction, isInteger, isNonEmptyString, isNonEmptyStringOrArrayOfNonEmptyStrings, methodCall, optionsHelp, reduceCallbacks, splitLongArray,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  methodCall = function(root, method, params, cb, after) {
    var apply, name, ref, ref1, ref2, ref3;
    if (after == null) {
      after = (function(ret) {
        return ret;
      });
    }
    apply = (ref = (ref1 = Job._ddp_apply) != null ? ref1[(ref2 = root.root) != null ? ref2 : root] : void 0) != null ? ref : Job._ddp_apply;
    if (typeof apply !== 'function') {
      throw new Error("Job remote method call error, no valid invocation method found.");
    }
    name = ((ref3 = root.root) != null ? ref3 : root) + "_" + method;
    if (cb && typeof cb === 'function') {
      return apply(name, params, (function(_this) {
        return function(err, res) {
          if (err) {
            return cb(err);
          }
          return cb(null, after(res));
        };
      })(this));
    } else {
      return after(apply(name, params));
    }
  };

  optionsHelp = function(options, cb) {
    var ref;
    if ((cb != null) && typeof cb !== 'function') {
      options = cb;
      cb = void 0;
    } else {
      if (!(typeof options === 'object' && options instanceof Array && options.length < 2)) {
        throw new Error('options... in optionsHelp must be an Array with zero or one elements');
      }
      options = (ref = options != null ? options[0] : void 0) != null ? ref : {};
    }
    if (typeof options !== 'object') {
      throw new Error('in optionsHelp options not an object or bad callback');
    }
    return [options, cb];
  };

  splitLongArray = function(arr, max) {
    var i, k, ref, results;
    if (!(arr instanceof Array && max > 0)) {
      throw new Error('splitLongArray: bad params');
    }
    results = [];
    for (i = k = 0, ref = Math.ceil(arr.length / max); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      results.push(arr.slice(i * max, (i + 1) * max));
    }
    return results;
  };

  reduceCallbacks = function(cb, num, reduce, init) {
    var cbCount, cbErr, cbRetVal;
    if (reduce == null) {
      reduce = (function(a, b) {
        return a || b;
      });
    }
    if (init == null) {
      init = false;
    }
    if (cb == null) {
      return void 0;
    }
    if (!(typeof cb === 'function' && num > 0 && typeof reduce === 'function')) {
      throw new Error('Bad params given to reduceCallbacks');
    }
    cbRetVal = init;
    cbCount = 0;
    cbErr = null;
    return function(err, res) {
      if (!cbErr) {
        if (err) {
          cbErr = err;
          return cb(err);
        } else {
          cbCount++;
          cbRetVal = reduce(cbRetVal, res);
          if (cbCount === num) {
            return cb(null, cbRetVal);
          } else if (cbCount > num) {
            throw new Error("reduceCallbacks callback invoked more than requested " + num + " times");
          }
        }
      }
    };
  };

  concatReduce = function(a, b) {
    if (!(a instanceof Array)) {
      a = [a];
    }
    return a.concat(b);
  };

  isInteger = function(i) {
    return typeof i === 'number' && Math.floor(i) === i;
  };

  isBoolean = function(b) {
    return typeof b === 'boolean';
  };

  isFunction = function(f) {
    return typeof f === 'function';
  };

  isNonEmptyString = function(s) {
    return typeof s === 'string' && s.length > 0;
  };

  isNonEmptyStringOrArrayOfNonEmptyStrings = function(sa) {
    var s;
    return isNonEmptyString(sa) || sa instanceof Array && sa.length !== 0 && ((function() {
      var k, len, results;
      results = [];
      for (k = 0, len = sa.length; k < len; k++) {
        s = sa[k];
        if (isNonEmptyString(s)) {
          results.push(s);
        }
      }
      return results;
    })()).length === sa.length;
  };

  _setImmediate = function() {
    var args, func;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.setTimeout : void 0) != null) {
      return Meteor.setTimeout.apply(Meteor, [func, 0].concat(slice.call(args)));
    } else if (typeof setImmediate !== "undefined" && setImmediate !== null) {
      return setImmediate.apply(null, [func].concat(slice.call(args)));
    } else {
      return setTimeout.apply(null, [func, 0].concat(slice.call(args)));
    }
  };

  _setInterval = function() {
    var args, func, timeOut;
    func = arguments[0], timeOut = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    if ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.setInterval : void 0) != null) {
      return Meteor.setInterval.apply(Meteor, [func, timeOut].concat(slice.call(args)));
    } else {
      return setInterval.apply(null, [func, timeOut].concat(slice.call(args)));
    }
  };

  _clearInterval = function(id) {
    if ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.clearInterval : void 0) != null) {
      return Meteor.clearInterval(id);
    } else {
      return clearInterval(id);
    }
  };

  JobQueue = (function() {
    function JobQueue() {
      var k, options, ref, ref1, ref2, ref3, ref4, root1, type1, worker;
      root1 = arguments[0], type1 = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), worker = arguments[k++];
      this.root = root1;
      this.type = type1;
      this.worker = worker;
      if (!(this instanceof JobQueue)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(JobQueue, [this.root, this.type].concat(slice.call(options), [this.worker]), function(){});
      }
      ref = optionsHelp(options, this.worker), options = ref[0], this.worker = ref[1];
      if (!isNonEmptyString(this.root)) {
        throw new Error("JobQueue: Invalid root, must be nonempty string");
      }
      if (!isNonEmptyStringOrArrayOfNonEmptyStrings(this.type)) {
        throw new Error("JobQueue: Invalid type, must be nonempty string or array of nonempty strings");
      }
      if (!isFunction(this.worker)) {
        throw new Error("JobQueue: Invalid worker, must be a function");
      }
      this.errorCallback = (ref1 = options.errorCallback) != null ? ref1 : function(e) {
        return console.error("JobQueue: ", e);
      };
      if (!isFunction(this.errorCallback)) {
        throw new Error("JobQueue: Invalid errorCallback, must be a function");
      }
      this.pollInterval = (options.pollInterval != null) && !options.pollInterval ? Job.forever : !((options.pollInterval != null) && isInteger(options.pollInterval)) ? 5000 : options.pollInterval;
      if (!(isInteger(this.pollInterval) && this.pollInterval >= 0)) {
        throw new Error("JobQueue: Invalid pollInterval, must be a positive integer");
      }
      this.concurrency = (ref2 = options.concurrency) != null ? ref2 : 1;
      if (!(isInteger(this.concurrency) && this.concurrency >= 0)) {
        throw new Error("JobQueue: Invalid concurrency, must be a positive integer");
      }
      this.payload = (ref3 = options.payload) != null ? ref3 : 1;
      if (!(isInteger(this.payload) && this.payload >= 0)) {
        throw new Error("JobQueue: Invalid payload, must be a positive integer");
      }
      this.prefetch = (ref4 = options.prefetch) != null ? ref4 : 0;
      if (!(isInteger(this.prefetch) && this.prefetch >= 0)) {
        throw new Error("JobQueue: Invalid prefetch, must be a positive integer");
      }
      this.workTimeout = options.workTimeout;
      if ((this.workTimeout != null) && !(isInteger(this.workTimeout) && this.workTimeout >= 0)) {
        throw new Error("JobQueue: Invalid workTimeout, must be a positive integer");
      }
      this.callbackStrict = options.callbackStrict;
      if ((this.callbackStrict != null) && !isBoolean(this.callbackStrict)) {
        throw new Error("JobQueue: Invalid callbackStrict, must be a boolean");
      }
      this._workers = {};
      this._tasks = [];
      this._taskNumber = 0;
      this._stoppingGetWork = void 0;
      this._stoppingTasks = void 0;
      this._interval = null;
      this._getWorkOutstanding = false;
      this.paused = true;
      this.resume();
    }

    JobQueue.prototype._getWork = function() {
      var numJobsToGet, options;
      if (!(this._getWorkOutstanding || this.paused)) {
        numJobsToGet = this.prefetch + this.payload * (this.concurrency - this.running()) - this.length();
        if (numJobsToGet > 0) {
          this._getWorkOutstanding = true;
          options = {
            maxJobs: numJobsToGet
          };
          if (this.workTimeout != null) {
            options.workTimeout = this.workTimeout;
          }
          return Job.getWork(this.root, this.type, options, (function(_this) {
            return function(err, jobs) {
              var j, k, len;
              _this._getWorkOutstanding = false;
              if (err) {
                return _this.errorCallback(new Error("Received error from getWork(): " + err));
              } else if ((jobs != null) && jobs instanceof Array) {
                if (jobs.length > numJobsToGet) {
                  _this.errorCallback(new Error("getWork() returned jobs (" + jobs.length + ") in excess of maxJobs (" + numJobsToGet + ")"));
                }
                for (k = 0, len = jobs.length; k < len; k++) {
                  j = jobs[k];
                  _this._tasks.push(j);
                  if (_this._stoppingGetWork == null) {
                    _setImmediate(_this._process.bind(_this));
                  }
                }
                if (_this._stoppingGetWork != null) {
                  return _this._stoppingGetWork();
                }
              } else {
                return _this.errorCallback(new Error("Nonarray response from server from getWork()"));
              }
            };
          })(this));
        }
      }
    };

    JobQueue.prototype._only_once = function(fn) {
      var called;
      called = false;
      return (function(_this) {
        return function() {
          if (called) {
            _this.errorCallback(new Error("Worker callback called multiple times"));
            if (_this.callbackStrict) {
              throw new Error("JobQueue: worker callback was invoked multiple times");
            }
          }
          called = true;
          return fn.apply(_this, arguments);
        };
      })(this);
    };

    JobQueue.prototype._process = function() {
      var cb, job, next;
      if (!this.paused && this.running() < this.concurrency && this.length()) {
        if (this.payload > 1) {
          job = this._tasks.splice(0, this.payload);
        } else {
          job = this._tasks.shift();
        }
        job._taskId = "Task_" + (this._taskNumber++);
        this._workers[job._taskId] = job;
        next = (function(_this) {
          return function() {
            delete _this._workers[job._taskId];
            if ((_this._stoppingTasks != null) && _this.running() === 0 && _this.length() === 0) {
              return _this._stoppingTasks();
            } else {
              _setImmediate(_this._process.bind(_this));
              return _setImmediate(_this._getWork.bind(_this));
            }
          };
        })(this);
        cb = this._only_once(next);
        return this.worker(job, cb);
      }
    };

    JobQueue.prototype._stopGetWork = function(callback) {
      _clearInterval(this._interval);
      this._interval = null;
      if (this._getWorkOutstanding) {
        return this._stoppingGetWork = callback;
      } else {
        return _setImmediate(callback);
      }
    };

    JobQueue.prototype._waitForTasks = function(callback) {
      if (this.running() !== 0) {
        return this._stoppingTasks = callback;
      } else {
        return _setImmediate(callback);
      }
    };

    JobQueue.prototype._failJobs = function(tasks, callback) {
      var count, job, k, len, results;
      if (tasks.length === 0) {
        _setImmediate(callback);
      }
      count = 0;
      results = [];
      for (k = 0, len = tasks.length; k < len; k++) {
        job = tasks[k];
        results.push(job.fail("Worker shutdown", (function(_this) {
          return function(err, res) {
            count++;
            if (count === tasks.length) {
              return callback();
            }
          };
        })(this)));
      }
      return results;
    };

    JobQueue.prototype._hard = function(callback) {
      this.paused = true;
      return this._stopGetWork((function(_this) {
        return function() {
          var i, r, ref, tasks;
          tasks = _this._tasks;
          _this._tasks = [];
          ref = _this._workers;
          for (i in ref) {
            r = ref[i];
            tasks = tasks.concat(r);
          }
          return _this._failJobs(tasks, callback);
        };
      })(this));
    };

    JobQueue.prototype._stop = function(callback) {
      this.paused = true;
      return this._stopGetWork((function(_this) {
        return function() {
          var tasks;
          tasks = _this._tasks;
          _this._tasks = [];
          return _this._waitForTasks(function() {
            return _this._failJobs(tasks, callback);
          });
        };
      })(this));
    };

    JobQueue.prototype._soft = function(callback) {
      return this._stopGetWork((function(_this) {
        return function() {
          return _this._waitForTasks(callback);
        };
      })(this));
    };

    JobQueue.prototype.length = function() {
      return this._tasks.length;
    };

    JobQueue.prototype.running = function() {
      return Object.keys(this._workers).length;
    };

    JobQueue.prototype.idle = function() {
      return this.length() + this.running() === 0;
    };

    JobQueue.prototype.full = function() {
      return this.running() === this.concurrency;
    };

    JobQueue.prototype.pause = function() {
      if (this.paused) {
        return;
      }
      if (!(this.pollInterval >= Job.forever)) {
        _clearInterval(this._interval);
        this._interval = null;
      }
      this.paused = true;
      return this;
    };

    JobQueue.prototype.resume = function() {
      var k, ref, w;
      if (!this.paused) {
        return;
      }
      this.paused = false;
      _setImmediate(this._getWork.bind(this));
      if (!(this.pollInterval >= Job.forever)) {
        this._interval = _setInterval(this._getWork.bind(this), this.pollInterval);
      }
      for (w = k = 1, ref = this.concurrency; 1 <= ref ? k <= ref : k >= ref; w = 1 <= ref ? ++k : --k) {
        _setImmediate(this._process.bind(this));
      }
      return this;
    };

    JobQueue.prototype.trigger = function() {
      if (this.paused) {
        return;
      }
      _setImmediate(this._getWork.bind(this));
      return this;
    };

    JobQueue.prototype.shutdown = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.level == null) {
        options.level = 'normal';
      }
      if (options.quiet == null) {
        options.quiet = false;
      }
      if (cb == null) {
        if (!options.quiet) {
          console.warn("using default shutdown callback!");
        }
        cb = (function(_this) {
          return function() {
            return console.warn("Shutdown complete");
          };
        })(this);
      }
      switch (options.level) {
        case 'hard':
          if (!options.quiet) {
            console.warn("Shutting down hard");
          }
          return this._hard(cb);
        case 'soft':
          if (!options.quiet) {
            console.warn("Shutting down soft");
          }
          return this._soft(cb);
        default:
          if (!options.quiet) {
            console.warn("Shutting down normally");
          }
          return this._stop(cb);
      }
    };

    return JobQueue;

  })();

  Job = (function() {
    Job.forever = 9007199254740992;

    Job.foreverDate = new Date(8640000000000000);

    Job.jobPriorities = {
      low: 10,
      normal: 0,
      medium: -5,
      high: -10,
      critical: -15
    };

    Job.jobRetryBackoffMethods = ['constant', 'exponential'];

    Job.jobStatuses = ['waiting', 'paused', 'ready', 'running', 'failed', 'cancelled', 'completed'];

    Job.jobLogLevels = ['info', 'success', 'warning', 'danger'];

    Job.jobStatusCancellable = ['running', 'ready', 'waiting', 'paused'];

    Job.jobStatusPausable = ['ready', 'waiting'];

    Job.jobStatusRemovable = ['cancelled', 'completed', 'failed'];

    Job.jobStatusRestartable = ['cancelled', 'failed'];

    Job.ddpMethods = ['startJobs', 'stopJobs', 'startJobServer', 'shutdownJobServer', 'jobRemove', 'jobPause', 'jobResume', 'jobReady', 'jobCancel', 'jobRestart', 'jobSave', 'jobRerun', 'getWork', 'getJob', 'jobLog', 'jobProgress', 'jobDone', 'jobFail'];

    Job.ddpPermissionLevels = ['admin', 'manager', 'creator', 'worker'];

    Job.ddpMethodPermissions = {
      'startJobs': ['startJobs', 'admin'],
      'stopJobs': ['stopJobs', 'admin'],
      'startJobServer': ['startJobServer', 'admin'],
      'shutdownJobServer': ['shutdownJobServer', 'admin'],
      'jobRemove': ['jobRemove', 'admin', 'manager'],
      'jobPause': ['jobPause', 'admin', 'manager'],
      'jobResume': ['jobResume', 'admin', 'manager'],
      'jobCancel': ['jobCancel', 'admin', 'manager'],
      'jobReady': ['jobReady', 'admin', 'manager'],
      'jobRestart': ['jobRestart', 'admin', 'manager'],
      'jobSave': ['jobSave', 'admin', 'creator'],
      'jobRerun': ['jobRerun', 'admin', 'creator'],
      'getWork': ['getWork', 'admin', 'worker'],
      'getJob': ['getJob', 'admin', 'worker'],
      'jobLog': ['jobLog', 'admin', 'worker'],
      'jobProgress': ['jobProgress', 'admin', 'worker'],
      'jobDone': ['jobDone', 'admin', 'worker'],
      'jobFail': ['jobFail', 'admin', 'worker']
    };

    Job._ddp_apply = void 0;

    Job._setDDPApply = function(apply, collectionName) {
      if (typeof apply === 'function') {
        if (typeof collectionName === 'string') {
          if (this._ddp_apply == null) {
            this._ddp_apply = {};
          }
          if (typeof this._ddp_apply === 'function') {
            throw new Error("Job.setDDP must specify a collection name each time if called more than once.");
          }
          return this._ddp_apply[collectionName] = apply;
        } else if (!this._ddp_apply) {
          return this._ddp_apply = apply;
        } else {
          throw new Error("Job.setDDP must specify a collection name each time if called more than once.");
        }
      } else {
        throw new Error("Bad function in Job.setDDPApply()");
      }
    };

    Job.setDDP = function(ddp, collectionNames, Fiber) {
      var collName, k, len, results;
      if (ddp == null) {
        ddp = null;
      }
      if (collectionNames == null) {
        collectionNames = null;
      }
      if (Fiber == null) {
        Fiber = null;
      }
      if (!((typeof collectionNames === 'string') || (collectionNames instanceof Array))) {
        Fiber = collectionNames;
        collectionNames = [void 0];
      } else if (typeof collectionNames === 'string') {
        collectionNames = [collectionNames];
      }
      results = [];
      for (k = 0, len = collectionNames.length; k < len; k++) {
        collName = collectionNames[k];
        if (!((ddp != null) && (ddp.close != null) && (ddp.subscribe != null))) {
          if (ddp === null && ((typeof Meteor !== "undefined" && Meteor !== null ? Meteor.apply : void 0) != null)) {
            results.push(this._setDDPApply(Meteor.apply, collName));
          } else {
            throw new Error("Bad ddp object in Job.setDDP()");
          }
        } else if (ddp.observe == null) {
          results.push(this._setDDPApply(ddp.apply.bind(ddp), collName));
        } else {
          if (Fiber == null) {
            results.push(this._setDDPApply(ddp.call.bind(ddp), collName));
          } else {
            results.push(this._setDDPApply((function(name, params, cb) {
              var fib;
              fib = Fiber.current;
              ddp.call(name, params, function(err, res) {
                if ((cb != null) && typeof cb === 'function') {
                  return cb(err, res);
                } else {
                  if (err) {
                    return fib.throwInto(err);
                  } else {
                    return fib.run(res);
                  }
                }
              });
              if ((cb != null) && typeof cb === 'function') {

              } else {
                return Fiber["yield"]();
              }
            }), collName));
          }
        }
      }
      return results;
    };

    Job.getWork = function() {
      var cb, k, options, ref, root, type;
      root = arguments[0], type = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (typeof type === 'string') {
        type = [type];
      }
      if (options.workTimeout != null) {
        if (!(isInteger(options.workTimeout) && options.workTimeout > 0)) {
          throw new Error('getWork: workTimeout must be a positive integer');
        }
      }
      return methodCall(root, "getWork", [type, options], cb, (function(_this) {
        return function(res) {
          var doc, jobs;
          jobs = ((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = res.length; l < len; l++) {
              doc = res[l];
              results.push(new Job(root, doc));
            }
            return results;
          })()) || [];
          if (options.maxJobs != null) {
            return jobs;
          } else {
            return jobs[0];
          }
        };
      })(this));
    };

    Job.processJobs = JobQueue;

    Job.makeJob = (function() {
      var depFlag;
      depFlag = false;
      return function(root, doc) {
        if (!depFlag) {
          depFlag = true;
          console.warn("Job.makeJob(root, jobDoc) has been deprecated and will be removed in a future release, use 'new Job(root, jobDoc)' instead.");
        }
        return new Job(root, doc);
      };
    })();

    Job.getJob = function() {
      var cb, id, k, options, ref, root;
      root = arguments[0], id = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.getLog == null) {
        options.getLog = false;
      }
      return methodCall(root, "getJob", [id, options], cb, (function(_this) {
        return function(doc) {
          if (doc) {
            return new Job(root, doc);
          } else {
            return void 0;
          }
        };
      })(this));
    };

    Job.getJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.getLog == null) {
        options.getLog = false;
      }
      retVal = [];
      chunksOfIds = splitLongArray(ids, 32);
      myCb = reduceCallbacks(cb, chunksOfIds.length, concatReduce, []);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = retVal.concat(methodCall(root, "getJob", [chunkOfIds, options], myCb, (function(_this) {
          return function(doc) {
            var d, len1, m, results;
            if (doc) {
              results = [];
              for (m = 0, len1 = doc.length; m < len1; m++) {
                d = doc[m];
                results.push(new Job(root, d.type, d.data, d));
              }
              return results;
            } else {
              return null;
            }
          };
        })(this)));
      }
      return retVal;
    };

    Job.pauseJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      retVal = false;
      chunksOfIds = splitLongArray(ids, 256);
      myCb = reduceCallbacks(cb, chunksOfIds.length);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = methodCall(root, "jobPause", [chunkOfIds, options], myCb) || retVal;
      }
      return retVal;
    };

    Job.resumeJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      retVal = false;
      chunksOfIds = splitLongArray(ids, 256);
      myCb = reduceCallbacks(cb, chunksOfIds.length);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = methodCall(root, "jobResume", [chunkOfIds, options], myCb) || retVal;
      }
      return retVal;
    };

    Job.readyJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      if (ids == null) {
        ids = [];
      }
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.force == null) {
        options.force = false;
      }
      retVal = false;
      chunksOfIds = splitLongArray(ids, 256);
      if (!(chunksOfIds.length > 0)) {
        chunksOfIds = [[]];
      }
      myCb = reduceCallbacks(cb, chunksOfIds.length);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = methodCall(root, "jobReady", [chunkOfIds, options], myCb) || retVal;
      }
      return retVal;
    };

    Job.cancelJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.antecedents == null) {
        options.antecedents = true;
      }
      retVal = false;
      chunksOfIds = splitLongArray(ids, 256);
      myCb = reduceCallbacks(cb, chunksOfIds.length);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = methodCall(root, "jobCancel", [chunkOfIds, options], myCb) || retVal;
      }
      return retVal;
    };

    Job.restartJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.retries == null) {
        options.retries = 1;
      }
      if (options.dependents == null) {
        options.dependents = true;
      }
      retVal = false;
      chunksOfIds = splitLongArray(ids, 256);
      myCb = reduceCallbacks(cb, chunksOfIds.length);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = methodCall(root, "jobRestart", [chunkOfIds, options], myCb) || retVal;
      }
      return retVal;
    };

    Job.removeJobs = function() {
      var cb, chunkOfIds, chunksOfIds, ids, k, l, len, myCb, options, ref, retVal, root;
      root = arguments[0], ids = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      retVal = false;
      chunksOfIds = splitLongArray(ids, 256);
      myCb = reduceCallbacks(cb, chunksOfIds.length);
      for (l = 0, len = chunksOfIds.length; l < len; l++) {
        chunkOfIds = chunksOfIds[l];
        retVal = methodCall(root, "jobRemove", [chunkOfIds, options], myCb) || retVal;
      }
      return retVal;
    };

    Job.startJobs = function() {
      var cb, k, options, ref, root;
      root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      return methodCall(root, "startJobs", [options], cb);
    };

    Job.stopJobs = function() {
      var cb, k, options, ref, root;
      root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.timeout == null) {
        options.timeout = 60 * 1000;
      }
      return methodCall(root, "stopJobs", [options], cb);
    };

    Job.startJobServer = function() {
      var cb, k, options, ref, root;
      root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      return methodCall(root, "startJobServer", [options], cb);
    };

    Job.shutdownJobServer = function() {
      var cb, k, options, ref, root;
      root = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.timeout == null) {
        options.timeout = 60 * 1000;
      }
      return methodCall(root, "shutdownJobServer", [options], cb);
    };

    function Job(rootVal, type, data) {
      var doc, ref, time;
      if (!(this instanceof Job)) {
        return new Job(rootVal, type, data);
      }
      this.root = rootVal;
      this._root = rootVal;
      if ((((ref = this.root) != null ? ref.root : void 0) != null) && typeof this.root.root === 'string') {
        this.root = this._root.root;
      }
      if ((data == null) && ((type != null ? type.data : void 0) != null) && ((type != null ? type.type : void 0) != null)) {
        if (type instanceof Job) {
          return type;
        }
        doc = type;
        data = doc.data;
        type = doc.type;
      } else {
        doc = {};
      }
      if (!(typeof doc === 'object' && typeof data === 'object' && typeof type === 'string' && typeof this.root === 'string')) {
        throw new Error("new Job: bad parameter(s), " + this.root + " (" + (typeof this.root) + "), " + type + " (" + (typeof type) + "), " + data + " (" + (typeof data) + "), " + doc + " (" + (typeof doc) + ")");
      } else if ((doc.type != null) && (doc.data != null)) {
        this._doc = doc;
      } else {
        time = new Date();
        this._doc = {
          runId: null,
          type: type,
          data: data,
          status: 'waiting',
          updated: time,
          created: time
        };
        this.priority().retry().repeat().after().progress().depends().log("Constructed");
      }
      return this;
    }

    Job.prototype._echo = function(message, level) {
      if (level == null) {
        level = null;
      }
      switch (level) {
        case 'danger':
          console.error(message);
          break;
        case 'warning':
          console.warn(message);
          break;
        case 'success':
          console.log(message);
          break;
        default:
          console.info(message);
      }
    };

    Job.prototype.depends = function(jobs) {
      var depends, j, k, len;
      if (jobs) {
        if (jobs instanceof Job) {
          jobs = [jobs];
        }
        if (jobs instanceof Array) {
          depends = this._doc.depends;
          for (k = 0, len = jobs.length; k < len; k++) {
            j = jobs[k];
            if (!(j instanceof Job && (j._doc._id != null))) {
              throw new Error('Each provided object must be a saved Job instance (with an _id)');
            }
            depends.push(j._doc._id);
          }
        } else {
          throw new Error('Bad input parameter: depends() accepts a falsy value, or Job or array of Jobs');
        }
      } else {
        depends = [];
      }
      this._doc.depends = depends;
      this._doc.resolved = [];
      return this;
    };

    Job.prototype.priority = function(level) {
      var priority;
      if (level == null) {
        level = 0;
      }
      if (typeof level === 'string') {
        priority = Job.jobPriorities[level];
        if (priority == null) {
          throw new Error('Invalid string priority level provided');
        }
      } else if (isInteger(level)) {
        priority = level;
      } else {
        throw new Error('priority must be an integer or valid priority level');
        priority = 0;
      }
      this._doc.priority = priority;
      return this;
    };

    Job.prototype.retry = function(options) {
      var base, ref;
      if (options == null) {
        options = 0;
      }
      if (isInteger(options) && options >= 0) {
        options = {
          retries: options
        };
      }
      if (typeof options !== 'object') {
        throw new Error('bad parameter: accepts either an integer >= 0 or an options object');
      }
      if (options.retries != null) {
        if (!(isInteger(options.retries) && options.retries >= 0)) {
          throw new Error('bad option: retries must be an integer >= 0');
        }
        options.retries++;
      } else {
        options.retries = Job.forever;
      }
      if (options.until != null) {
        if (!(options.until instanceof Date)) {
          throw new Error('bad option: until must be a Date object');
        }
      } else {
        options.until = Job.foreverDate;
      }
      if (options.wait != null) {
        if (!(isInteger(options.wait) && options.wait >= 0)) {
          throw new Error('bad option: wait must be an integer >= 0');
        }
      } else {
        options.wait = 5 * 60 * 1000;
      }
      if (options.backoff != null) {
        if (ref = options.backoff, indexOf.call(Job.jobRetryBackoffMethods, ref) < 0) {
          throw new Error('bad option: invalid retry backoff method');
        }
      } else {
        options.backoff = 'constant';
      }
      this._doc.retries = options.retries;
      this._doc.repeatRetries = options.retries;
      this._doc.retryWait = options.wait;
      if ((base = this._doc).retried == null) {
        base.retried = 0;
      }
      this._doc.retryBackoff = options.backoff;
      this._doc.retryUntil = options.until;
      return this;
    };

    Job.prototype.repeat = function(options) {
      var base, ref;
      if (options == null) {
        options = 0;
      }
      if (isInteger(options) && options >= 0) {
        options = {
          repeats: options
        };
      }
      if (typeof options !== 'object') {
        throw new Error('bad parameter: accepts either an integer >= 0 or an options object');
      }
      if ((options.wait != null) && (options.schedule != null)) {
        throw new Error('bad options: wait and schedule options are mutually exclusive');
      }
      if (options.repeats != null) {
        if (!(isInteger(options.repeats) && options.repeats >= 0)) {
          throw new Error('bad option: repeats must be an integer >= 0');
        }
      } else {
        options.repeats = Job.forever;
      }
      if (options.until != null) {
        if (!(options.until instanceof Date)) {
          throw new Error('bad option: until must be a Date object');
        }
      } else {
        options.until = Job.foreverDate;
      }
      if (options.wait != null) {
        if (!(isInteger(options.wait) && options.wait >= 0)) {
          throw new Error('bad option: wait must be an integer >= 0');
        }
      } else {
        options.wait = 5 * 60 * 1000;
      }
      if (options.schedule != null) {
        if (typeof options.schedule !== 'object') {
          throw new Error('bad option, schedule option must be an object');
        }
        if (!((((ref = options.schedule) != null ? ref.schedules : void 0) != null) && options.schedule.schedules instanceof Array)) {
          throw new Error('bad option, schedule object requires a schedules attribute of type Array.');
        }
        if ((options.schedule.exceptions != null) && !(options.schedule.exceptions instanceof Array)) {
          throw new Error('bad option, schedule object exceptions attribute must be an Array');
        }
        options.wait = {
          schedules: options.schedule.schedules,
          exceptions: options.schedule.exceptions
        };
      }
      this._doc.repeats = options.repeats;
      this._doc.repeatWait = options.wait;
      if ((base = this._doc).repeated == null) {
        base.repeated = 0;
      }
      this._doc.repeatUntil = options.until;
      return this;
    };

    Job.prototype.delay = function(wait) {
      if (wait == null) {
        wait = 0;
      }
      if (!(isInteger(wait) && wait >= 0)) {
        throw new Error('Bad parameter, delay requires a non-negative integer.');
      }
      return this.after(new Date(new Date().valueOf() + wait));
    };

    Job.prototype.after = function(time) {
      var after;
      if (time == null) {
        time = new Date(0);
      }
      if (typeof time === 'object' && time instanceof Date) {
        after = time;
      } else {
        throw new Error('Bad parameter, after requires a valid Date object');
      }
      this._doc.after = after;
      return this;
    };

    Job.prototype.log = function() {
      var base, cb, k, message, options, ref, ref1;
      message = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.level == null) {
        options.level = 'info';
      }
      if (typeof message !== 'string') {
        throw new Error('Log message must be a string');
      }
      if (!(typeof options.level === 'string' && (ref1 = options.level, indexOf.call(Job.jobLogLevels, ref1) >= 0))) {
        throw new Error('Log level options must be one of Job.jobLogLevels');
      }
      if (options.echo != null) {
        if (options.echo && Job.jobLogLevels.indexOf(options.level) >= Job.jobLogLevels.indexOf(options.echo)) {
          this._echo("LOG: " + options.level + ", " + this._doc._id + " " + this._doc.runId + ": " + message, options.level);
        }
        delete options.echo;
      }
      if (this._doc._id != null) {
        return methodCall(this._root, "jobLog", [this._doc._id, this._doc.runId, message, options], cb);
      } else {
        if ((base = this._doc).log == null) {
          base.log = [];
        }
        this._doc.log.push({
          time: new Date(),
          runId: null,
          level: options.level,
          message: message
        });
        if ((cb != null) && typeof cb === 'function') {
          _setImmediate(cb, null, true);
        }
        return this;
      }
    };

    Job.prototype.progress = function() {
      var cb, completed, k, options, progress, ref, total;
      completed = arguments[0], total = arguments[1], options = 4 <= arguments.length ? slice.call(arguments, 2, k = arguments.length - 1) : (k = 2, []), cb = arguments[k++];
      if (completed == null) {
        completed = 0;
      }
      if (total == null) {
        total = 1;
      }
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (typeof completed === 'number' && typeof total === 'number' && completed >= 0 && total > 0 && total >= completed) {
        progress = {
          completed: completed,
          total: total,
          percent: 100 * completed / total
        };
        if (options.echo) {
          delete options.echo;
          this._echo("PROGRESS: " + this._doc._id + " " + this._doc.runId + ": " + progress.completed + " out of " + progress.total + " (" + progress.percent + "%)");
        }
        if ((this._doc._id != null) && (this._doc.runId != null)) {
          return methodCall(this._root, "jobProgress", [this._doc._id, this._doc.runId, completed, total, options], cb, (function(_this) {
            return function(res) {
              if (res) {
                _this._doc.progress = progress;
              }
              return res;
            };
          })(this));
        } else if (this._doc._id == null) {
          this._doc.progress = progress;
          if ((cb != null) && typeof cb === 'function') {
            _setImmediate(cb, null, true);
          }
          return this;
        }
      } else {
        throw new Error("job.progress: something is wrong with progress params: " + this.id + ", " + completed + " out of " + total);
      }
      return null;
    };

    Job.prototype.save = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      return methodCall(this._root, "jobSave", [this._doc, options], cb, (function(_this) {
        return function(id) {
          if (id) {
            _this._doc._id = id;
          }
          return id;
        };
      })(this));
    };

    Job.prototype.refresh = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.getLog == null) {
        options.getLog = false;
      }
      if (this._doc._id != null) {
        return methodCall(this._root, "getJob", [this._doc._id, options], cb, (function(_this) {
          return function(doc) {
            if (doc != null) {
              _this._doc = doc;
              return _this;
            } else {
              return false;
            }
          };
        })(this));
      } else {
        throw new Error("Can't call .refresh() on an unsaved job");
      }
    };

    Job.prototype.done = function() {
      var cb, k, options, ref, result;
      result = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      if (result == null) {
        result = {};
      }
      if (typeof result === 'function') {
        cb = result;
        result = {};
      }
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (!((result != null) && typeof result === 'object')) {
        result = {
          value: result
        };
      }
      if ((this._doc._id != null) && (this._doc.runId != null)) {
        return methodCall(this._root, "jobDone", [this._doc._id, this._doc.runId, result, options], cb);
      } else {
        throw new Error("Can't call .done() on an unsaved or non-running job");
      }
      return null;
    };

    Job.prototype.fail = function() {
      var cb, k, options, ref, result;
      result = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), cb = arguments[k++];
      if (result == null) {
        result = "No error information provided";
      }
      if (typeof result === 'function') {
        cb = result;
        result = "No error information provided";
      }
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (!((result != null) && typeof result === 'object')) {
        result = {
          value: result
        };
      }
      if (options.fatal == null) {
        options.fatal = false;
      }
      if ((this._doc._id != null) && (this._doc.runId != null)) {
        return methodCall(this._root, "jobFail", [this._doc._id, this._doc.runId, result, options], cb);
      } else {
        throw new Error("Can't call .fail() on an unsaved or non-running job");
      }
      return null;
    };

    Job.prototype.pause = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (this._doc._id != null) {
        return methodCall(this._root, "jobPause", [this._doc._id, options], cb);
      } else {
        this._doc.status = 'paused';
        if ((cb != null) && typeof cb === 'function') {
          _setImmediate(cb, null, true);
        }
        return this;
      }
      return null;
    };

    Job.prototype.resume = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (this._doc._id != null) {
        return methodCall(this._root, "jobResume", [this._doc._id, options], cb);
      } else {
        this._doc.status = 'waiting';
        if ((cb != null) && typeof cb === 'function') {
          _setImmediate(cb, null, true);
        }
        return this;
      }
      return null;
    };

    Job.prototype.ready = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.force == null) {
        options.force = false;
      }
      if (this._doc._id != null) {
        return methodCall(this._root, "jobReady", [this._doc._id, options], cb);
      } else {
        throw new Error("Can't call .ready() on an unsaved job");
      }
      return null;
    };

    Job.prototype.cancel = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.antecedents == null) {
        options.antecedents = true;
      }
      if (this._doc._id != null) {
        return methodCall(this._root, "jobCancel", [this._doc._id, options], cb);
      } else {
        throw new Error("Can't call .cancel() on an unsaved job");
      }
      return null;
    };

    Job.prototype.restart = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.retries == null) {
        options.retries = 1;
      }
      if (options.dependents == null) {
        options.dependents = true;
      }
      if (this._doc._id != null) {
        return methodCall(this._root, "jobRestart", [this._doc._id, options], cb);
      } else {
        throw new Error("Can't call .restart() on an unsaved job");
      }
      return null;
    };

    Job.prototype.rerun = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (options.repeats == null) {
        options.repeats = 0;
      }
      if (options.wait == null) {
        options.wait = this._doc.repeatWait;
      }
      if (this._doc._id != null) {
        return methodCall(this._root, "jobRerun", [this._doc._id, options], cb);
      } else {
        throw new Error("Can't call .rerun() on an unsaved job");
      }
      return null;
    };

    Job.prototype.remove = function() {
      var cb, k, options, ref;
      options = 2 <= arguments.length ? slice.call(arguments, 0, k = arguments.length - 1) : (k = 0, []), cb = arguments[k++];
      ref = optionsHelp(options, cb), options = ref[0], cb = ref[1];
      if (this._doc._id != null) {
        return methodCall(this._root, "jobRemove", [this._doc._id, options], cb);
      } else {
        throw new Error("Can't call .remove() on an unsaved job");
      }
      return null;
    };

    Object.defineProperties(Job.prototype, {
      doc: {
        get: function() {
          return this._doc;
        },
        set: function() {
          return console.warn("Job.doc cannot be directly assigned.");
        }
      },
      type: {
        get: function() {
          return this._doc.type;
        },
        set: function() {
          return console.warn("Job.type cannot be directly assigned.");
        }
      },
      data: {
        get: function() {
          return this._doc.data;
        },
        set: function() {
          return console.warn("Job.data cannot be directly assigned.");
        }
      }
    });

    return Job;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Job;
  }

}).call(this);
